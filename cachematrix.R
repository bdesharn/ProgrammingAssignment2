# Assignment 2
# Brigitte Desharnais

#Creating first function: "makeCacheMatrix".
#This function has one argument, "x", which is a matrix.
#It will create a list with 4 functions:
     #set(y): which will set "y" as the matrix used by the other functions.
     #get(): which will retrieve the matrix used as an argument.
     #setmean(inv): which will set "inv" as the inversed matrix, "xinv".
     #getmean(): which will retrieve the inversed matrix, "xinv".
#Needs to be run as x <- makeCacheMatrix(--Matrix--) in order to work with cacheSolve.

makeCacheMatrix <- function(x = matrix()) {
     
     #The result of the inversion of the matrix will be stored in "xinv".
     #We start by setting that variable to NULL.
     xinv <- NULL
     
     #The function "set" takes one argument, "y".
     #It takes the matrix "y" and assigns it the variable name "x" in the parent environment.
     #The parent environment is "makeCacheMatrix".
     set <- function(y) {
          x <<- y
          xinv <<- NULL #This initializes "xinv" to NULL in the parent environment a second time.
     }
     
     #"get" is a function returning the matrix x. It doesn't take any argument.
     get <- function() x
     
     #"setInv" is a function that has one argument, "inv".
     #It will force the variable "xinv" to have a value "inv" (the input of the function) in the parent environement.
     setInv <- function(inv) xinv <<- inv
     
     #"getInv" is function that returns the inversed matrix "xinv". It just retrieves it and doesn't take any argument.
     getInv <- function() xinv
     
     #This will return a list of these 4 functions. These can be used by typing in the console:
          #x$set(NewMatrix)             [to change the matrix used]
          #x$get()                      [to retrieve the setted matrix]
          #x$setInv(InvertedMatrix)     [to set a matrix as the inversed matrix]
          #x$getInv()                   [to retrieve the inverted matrix]
     list(set = set, get = get,
          setInv = setInv,
          getInv = getInv)
}

#This function will go and look for an inverted matrix already computed and assigned to "xinv" in the "makeCacheMatrix"
#environment. If it doesn't find one, then it will perform the computation.
#In both cases, the inverted matrix is returned as the output of this function.
cacheSolve <- function(x, ...) {
     
     #This uses the x$getInv element/function generated by "makeCacheMatrix".
     #That retrieves "xinv" in the "makeCacheMatrix" environment,
     #and assigns it to "xinv" in the current, "cacheSolve" environment.
     xinv <- x$getInv()
     
     #If "xinv" was never calculated, it will be set as NULL,
     #since xinv <- NULL was the first step in "makeCacheMatrix".
     #The next line checks if there was ever a computation performed (if "xinv" is non-NULL).
     if(!is.null(xinv)) {
          
          #If there is indeed a computed matrix, the following message appears:
          message("getting cached data")
          
          #And the inverted matrix previously computed is returned:
          return(xinv)
     }
     
     #If there is no inverted matrix already computed, then one needs to be computed.
     #The first step is to retrieve the matrix to be inverted.
     #This is done using the x$get element/function generated by "makeCacheMatrix".
     #The matrix is assigned to "data".
     data <- x$get()
     
     #The matrix "data" is inverted using the "solve" function.
     xinv <- solve(data)
     
     #To cache the result and make it available for future retrieval,
     #the x$setInv element/function generated by "makeCacheMatrix" is used.
     x$setInv(xinv)
     
     #The inverted matrix just computed is returned:
     xinv
}
